//! This code was AUTOGENERATED using the kinobi library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun kinobi to update it.
//!
//! [https://github.com/metaplex-foundation/kinobi]
//!

use borsh::BorshDeserialize;
use borsh::BorshSerialize;

/// Accounts.
pub struct MintV1 {
    /// Candy Guard account.
    pub candy_guard: solana_program::pubkey::Pubkey,
    /// Candy Machine program account.
    ///
    pub candy_machine_program: solana_program::pubkey::Pubkey,
    /// Candy machine account.
    pub candy_machine: solana_program::pubkey::Pubkey,
    /// Candy Machine authority account.
    ///
    pub candy_machine_authority_pda: solana_program::pubkey::Pubkey,
    /// Payer for the mint (SOL) fees.
    pub payer: solana_program::pubkey::Pubkey,
    /// Minter account for validation and non-SOL fees.
    pub minter: solana_program::pubkey::Pubkey,
    /// Optionally mint to different owner
    pub owner: Option<solana_program::pubkey::Pubkey>,
    /// Mint account of the NFT. The account will be initialized if necessary.
    ///
    /// Must be a signer if:
    /// * the nft_mint account does not exist.
    ///
    pub asset: (solana_program::pubkey::Pubkey, bool),
    /// Mint account of the collection NFT.
    ///
    pub collection: solana_program::pubkey::Pubkey,
    /// Token Metadata program.
    ///
    /// Token Metadata program.
    ///
    pub mpl_core_program: solana_program::pubkey::Pubkey,
    /// SPL Token program.
    /// System program.
    pub system_program: solana_program::pubkey::Pubkey,
    /// Instructions sysvar account.
    ///
    pub sysvar_instructions: solana_program::pubkey::Pubkey,
    /// SlotHashes sysvar cluster data.
    ///
    pub recent_slothashes: solana_program::pubkey::Pubkey,
}

impl MintV1 {
    #[allow(clippy::vec_init_then_push)]
    pub fn instruction(
        &self,
        args: MintV1InstructionArgs,
    ) -> solana_program::instruction::Instruction {
        let mut accounts = Vec::with_capacity(13);
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            self.candy_guard,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            self.candy_machine_program,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            self.candy_machine,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            self.candy_machine_authority_pda,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            self.payer, true,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            self.minter,
            true,
        ));
        if let Some(owner) = self.owner {
            accounts.push(solana_program::instruction::AccountMeta::new_readonly(
                owner, false,
            ));
        } else {
            accounts.push(solana_program::instruction::AccountMeta::new_readonly(
                crate::MPL_CORE_CANDY_GUARD_ID,
                false,
            ));
        }
        accounts.push(solana_program::instruction::AccountMeta::new(
            self.asset.0,
            self.asset.1,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            self.collection,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            self.mpl_core_program,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            self.system_program,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            self.sysvar_instructions,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            self.recent_slothashes,
            false,
        ));
        let mut data = MintV1InstructionData::new().try_to_vec().unwrap();
        let mut args = args.try_to_vec().unwrap();
        data.append(&mut args);

        solana_program::instruction::Instruction {
            program_id: crate::MPL_CORE_CANDY_GUARD_ID,
            accounts,
            data,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
struct MintV1InstructionData {
    discriminator: [u8; 8],
}

impl MintV1InstructionData {
    fn new() -> Self {
        Self {
            discriminator: [145, 98, 192, 118, 184, 147, 118, 104],
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct MintV1InstructionArgs {
    pub mint_args: Vec<u8>,
    pub group: Option<String>,
}

/// Instruction builder.
#[derive(Default)]
pub struct MintV1Builder {
    candy_guard: Option<solana_program::pubkey::Pubkey>,
    candy_machine_program: Option<solana_program::pubkey::Pubkey>,
    candy_machine: Option<solana_program::pubkey::Pubkey>,
    candy_machine_authority_pda: Option<solana_program::pubkey::Pubkey>,
    payer: Option<solana_program::pubkey::Pubkey>,
    minter: Option<solana_program::pubkey::Pubkey>,
    owner: Option<solana_program::pubkey::Pubkey>,
    asset: Option<(solana_program::pubkey::Pubkey, bool)>,
    collection: Option<solana_program::pubkey::Pubkey>,
    mpl_core_program: Option<solana_program::pubkey::Pubkey>,
    system_program: Option<solana_program::pubkey::Pubkey>,
    sysvar_instructions: Option<solana_program::pubkey::Pubkey>,
    recent_slothashes: Option<solana_program::pubkey::Pubkey>,
    mint_args: Option<Vec<u8>>,
    group: Option<String>,
}

impl MintV1Builder {
    pub fn new() -> Self {
        Self::default()
    }
    /// Candy Guard account.
    #[inline(always)]
    pub fn candy_guard(&mut self, candy_guard: solana_program::pubkey::Pubkey) -> &mut Self {
        self.candy_guard = Some(candy_guard);
        self
    }
    /// Candy Machine program account.
    ///
    #[inline(always)]
    pub fn candy_machine_program(
        &mut self,
        candy_machine_program: solana_program::pubkey::Pubkey,
    ) -> &mut Self {
        self.candy_machine_program = Some(candy_machine_program);
        self
    }
    /// Candy machine account.
    #[inline(always)]
    pub fn candy_machine(&mut self, candy_machine: solana_program::pubkey::Pubkey) -> &mut Self {
        self.candy_machine = Some(candy_machine);
        self
    }
    /// Candy Machine authority account.
    ///
    #[inline(always)]
    pub fn candy_machine_authority_pda(
        &mut self,
        candy_machine_authority_pda: solana_program::pubkey::Pubkey,
    ) -> &mut Self {
        self.candy_machine_authority_pda = Some(candy_machine_authority_pda);
        self
    }
    /// Payer for the mint (SOL) fees.
    #[inline(always)]
    pub fn payer(&mut self, payer: solana_program::pubkey::Pubkey) -> &mut Self {
        self.payer = Some(payer);
        self
    }
    /// Minter account for validation and non-SOL fees.
    #[inline(always)]
    pub fn minter(&mut self, minter: solana_program::pubkey::Pubkey) -> &mut Self {
        self.minter = Some(minter);
        self
    }
    /// `[optional account]`
    /// Optionally mint to different owner
    #[inline(always)]
    pub fn owner(&mut self, owner: solana_program::pubkey::Pubkey) -> &mut Self {
        self.owner = Some(owner);
        self
    }
    /// Mint account of the NFT. The account will be initialized if necessary.
    ///
    /// Must be a signer if:
    /// * the nft_mint account does not exist.
    ///
    #[inline(always)]
    pub fn asset(&mut self, asset: solana_program::pubkey::Pubkey, as_signer: bool) -> &mut Self {
        self.asset = Some((asset, as_signer));
        self
    }
    /// Mint account of the collection NFT.
    ///
    #[inline(always)]
    pub fn collection(&mut self, collection: solana_program::pubkey::Pubkey) -> &mut Self {
        self.collection = Some(collection);
        self
    }
    /// Token Metadata program.
    ///
    /// Token Metadata program.
    ///
    #[inline(always)]
    pub fn mpl_core_program(
        &mut self,
        mpl_core_program: solana_program::pubkey::Pubkey,
    ) -> &mut Self {
        self.mpl_core_program = Some(mpl_core_program);
        self
    }
    /// SPL Token program.
    /// System program.
    #[inline(always)]
    pub fn system_program(&mut self, system_program: solana_program::pubkey::Pubkey) -> &mut Self {
        self.system_program = Some(system_program);
        self
    }
    /// Instructions sysvar account.
    ///
    #[inline(always)]
    pub fn sysvar_instructions(
        &mut self,
        sysvar_instructions: solana_program::pubkey::Pubkey,
    ) -> &mut Self {
        self.sysvar_instructions = Some(sysvar_instructions);
        self
    }
    /// SlotHashes sysvar cluster data.
    ///
    #[inline(always)]
    pub fn recent_slothashes(
        &mut self,
        recent_slothashes: solana_program::pubkey::Pubkey,
    ) -> &mut Self {
        self.recent_slothashes = Some(recent_slothashes);
        self
    }
    #[inline(always)]
    pub fn mint_args(&mut self, mint_args: Vec<u8>) -> &mut Self {
        self.mint_args = Some(mint_args);
        self
    }
    /// `[optional argument]`
    #[inline(always)]
    pub fn group(&mut self, group: String) -> &mut Self {
        self.group = Some(group);
        self
    }
    #[allow(clippy::clone_on_copy)]
    pub fn build(&self) -> solana_program::instruction::Instruction {
        let accounts =
            MintV1 {
                candy_guard: self.candy_guard.expect("candy_guard is not set"),
                candy_machine_program: self.candy_machine_program.unwrap_or(
                    solana_program::pubkey!("CMACYFENjoBMHzapRXyo1JZkVS6EtaDDzkjMrmQLvr4J"),
                ),
                candy_machine: self.candy_machine.expect("candy_machine is not set"),
                candy_machine_authority_pda: self
                    .candy_machine_authority_pda
                    .expect("candy_machine_authority_pda is not set"),
                payer: self.payer.expect("payer is not set"),
                minter: self.minter.expect("minter is not set"),
                owner: self.owner,
                asset: self.asset.expect("asset is not set"),
                collection: self.collection.expect("collection is not set"),
                mpl_core_program: self.mpl_core_program.unwrap_or(solana_program::pubkey!(
                    "CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d"
                )),
                system_program: self
                    .system_program
                    .unwrap_or(solana_program::pubkey!("11111111111111111111111111111111")),
                sysvar_instructions: self.sysvar_instructions.unwrap_or(solana_program::pubkey!(
                    "Sysvar1nstructions1111111111111111111111111"
                )),
                recent_slothashes: self.recent_slothashes.unwrap_or(solana_program::pubkey!(
                    "SysvarS1otHashes111111111111111111111111111"
                )),
            };
        let args = MintV1InstructionArgs {
            mint_args: self.mint_args.clone().expect("mint_args is not set"),
            group: self.group.clone(),
        };

        accounts.instruction(args)
    }
}

/// `mint_v1` CPI instruction.
pub struct MintV1Cpi<'a> {
    /// The program to invoke.
    pub __program: &'a solana_program::account_info::AccountInfo<'a>,
    /// Candy Guard account.
    pub candy_guard: &'a solana_program::account_info::AccountInfo<'a>,
    /// Candy Machine program account.
    ///
    pub candy_machine_program: &'a solana_program::account_info::AccountInfo<'a>,
    /// Candy machine account.
    pub candy_machine: &'a solana_program::account_info::AccountInfo<'a>,
    /// Candy Machine authority account.
    ///
    pub candy_machine_authority_pda: &'a solana_program::account_info::AccountInfo<'a>,
    /// Payer for the mint (SOL) fees.
    pub payer: &'a solana_program::account_info::AccountInfo<'a>,
    /// Minter account for validation and non-SOL fees.
    pub minter: &'a solana_program::account_info::AccountInfo<'a>,
    /// Optionally mint to different owner
    pub owner: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    /// Mint account of the NFT. The account will be initialized if necessary.
    ///
    /// Must be a signer if:
    /// * the nft_mint account does not exist.
    ///
    pub asset: (&'a solana_program::account_info::AccountInfo<'a>, bool),
    /// Mint account of the collection NFT.
    ///
    pub collection: &'a solana_program::account_info::AccountInfo<'a>,
    /// Token Metadata program.
    ///
    /// Token Metadata program.
    ///
    pub mpl_core_program: &'a solana_program::account_info::AccountInfo<'a>,
    /// SPL Token program.
    /// System program.
    pub system_program: &'a solana_program::account_info::AccountInfo<'a>,
    /// Instructions sysvar account.
    ///
    pub sysvar_instructions: &'a solana_program::account_info::AccountInfo<'a>,
    /// SlotHashes sysvar cluster data.
    ///
    pub recent_slothashes: &'a solana_program::account_info::AccountInfo<'a>,
    /// The arguments for the instruction.
    pub __args: MintV1InstructionArgs,
}

impl<'a> MintV1Cpi<'a> {
    pub fn invoke(&self) -> solana_program::entrypoint::ProgramResult {
        self.invoke_signed(&[])
    }
    #[allow(clippy::clone_on_copy)]
    #[allow(clippy::vec_init_then_push)]
    pub fn invoke_signed(
        &self,
        signers_seeds: &[&[&[u8]]],
    ) -> solana_program::entrypoint::ProgramResult {
        let mut accounts = Vec::with_capacity(13);
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            *self.candy_guard.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            *self.candy_machine_program.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            *self.candy_machine.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            *self.candy_machine_authority_pda.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            *self.payer.key,
            true,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            *self.minter.key,
            true,
        ));
        if let Some(owner) = self.owner {
            accounts.push(solana_program::instruction::AccountMeta::new_readonly(
                *owner.key, false,
            ));
        } else {
            accounts.push(solana_program::instruction::AccountMeta::new_readonly(
                crate::MPL_CORE_CANDY_GUARD_ID,
                false,
            ));
        }
        accounts.push(solana_program::instruction::AccountMeta::new(
            *self.asset.0.key,
            self.asset.1,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new(
            *self.collection.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            *self.mpl_core_program.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            *self.system_program.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            *self.sysvar_instructions.key,
            false,
        ));
        accounts.push(solana_program::instruction::AccountMeta::new_readonly(
            *self.recent_slothashes.key,
            false,
        ));
        let mut data = MintV1InstructionData::new().try_to_vec().unwrap();
        let mut args = self.__args.try_to_vec().unwrap();
        data.append(&mut args);

        let instruction = solana_program::instruction::Instruction {
            program_id: crate::MPL_CORE_CANDY_GUARD_ID,
            accounts,
            data,
        };
        let mut account_infos = Vec::with_capacity(13 + 1);
        account_infos.push(self.__program.clone());
        account_infos.push(self.candy_guard.clone());
        account_infos.push(self.candy_machine_program.clone());
        account_infos.push(self.candy_machine.clone());
        account_infos.push(self.candy_machine_authority_pda.clone());
        account_infos.push(self.payer.clone());
        account_infos.push(self.minter.clone());
        if let Some(owner) = self.owner {
            account_infos.push(owner.clone());
        }
        account_infos.push(self.asset.0.clone());
        account_infos.push(self.collection.clone());
        account_infos.push(self.mpl_core_program.clone());
        account_infos.push(self.system_program.clone());
        account_infos.push(self.sysvar_instructions.clone());
        account_infos.push(self.recent_slothashes.clone());

        if signers_seeds.is_empty() {
            solana_program::program::invoke(&instruction, &account_infos)
        } else {
            solana_program::program::invoke_signed(&instruction, &account_infos, signers_seeds)
        }
    }
}

/// `mint_v1` CPI instruction builder.
pub struct MintV1CpiBuilder<'a> {
    instruction: Box<MintV1CpiBuilderInstruction<'a>>,
}

impl<'a> MintV1CpiBuilder<'a> {
    pub fn new(program: &'a solana_program::account_info::AccountInfo<'a>) -> Self {
        let instruction = Box::new(MintV1CpiBuilderInstruction {
            __program: program,
            candy_guard: None,
            candy_machine_program: None,
            candy_machine: None,
            candy_machine_authority_pda: None,
            payer: None,
            minter: None,
            owner: None,
            asset: None,
            collection: None,
            mpl_core_program: None,
            system_program: None,
            sysvar_instructions: None,
            recent_slothashes: None,
            mint_args: None,
            group: None,
        });
        Self { instruction }
    }
    /// Candy Guard account.
    #[inline(always)]
    pub fn candy_guard(
        &mut self,
        candy_guard: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.candy_guard = Some(candy_guard);
        self
    }
    /// Candy Machine program account.
    ///
    #[inline(always)]
    pub fn candy_machine_program(
        &mut self,
        candy_machine_program: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.candy_machine_program = Some(candy_machine_program);
        self
    }
    /// Candy machine account.
    #[inline(always)]
    pub fn candy_machine(
        &mut self,
        candy_machine: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.candy_machine = Some(candy_machine);
        self
    }
    /// Candy Machine authority account.
    ///
    #[inline(always)]
    pub fn candy_machine_authority_pda(
        &mut self,
        candy_machine_authority_pda: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.candy_machine_authority_pda = Some(candy_machine_authority_pda);
        self
    }
    /// Payer for the mint (SOL) fees.
    #[inline(always)]
    pub fn payer(&mut self, payer: &'a solana_program::account_info::AccountInfo<'a>) -> &mut Self {
        self.instruction.payer = Some(payer);
        self
    }
    /// Minter account for validation and non-SOL fees.
    #[inline(always)]
    pub fn minter(
        &mut self,
        minter: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.minter = Some(minter);
        self
    }
    /// `[optional account]`
    /// Optionally mint to different owner
    #[inline(always)]
    pub fn owner(&mut self, owner: &'a solana_program::account_info::AccountInfo<'a>) -> &mut Self {
        self.instruction.owner = Some(owner);
        self
    }
    /// Mint account of the NFT. The account will be initialized if necessary.
    ///
    /// Must be a signer if:
    /// * the nft_mint account does not exist.
    ///
    #[inline(always)]
    pub fn asset(
        &mut self,
        asset: &'a solana_program::account_info::AccountInfo<'a>,
        as_signer: bool,
    ) -> &mut Self {
        self.instruction.asset = Some((asset, as_signer));
        self
    }
    /// Mint account of the collection NFT.
    ///
    #[inline(always)]
    pub fn collection(
        &mut self,
        collection: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.collection = Some(collection);
        self
    }
    /// Token Metadata program.
    ///
    /// Token Metadata program.
    ///
    #[inline(always)]
    pub fn mpl_core_program(
        &mut self,
        mpl_core_program: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.mpl_core_program = Some(mpl_core_program);
        self
    }
    /// SPL Token program.
    /// System program.
    #[inline(always)]
    pub fn system_program(
        &mut self,
        system_program: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.system_program = Some(system_program);
        self
    }
    /// Instructions sysvar account.
    ///
    #[inline(always)]
    pub fn sysvar_instructions(
        &mut self,
        sysvar_instructions: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.sysvar_instructions = Some(sysvar_instructions);
        self
    }
    /// SlotHashes sysvar cluster data.
    ///
    #[inline(always)]
    pub fn recent_slothashes(
        &mut self,
        recent_slothashes: &'a solana_program::account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.recent_slothashes = Some(recent_slothashes);
        self
    }
    #[inline(always)]
    pub fn mint_args(&mut self, mint_args: Vec<u8>) -> &mut Self {
        self.instruction.mint_args = Some(mint_args);
        self
    }
    /// `[optional argument]`
    #[inline(always)]
    pub fn group(&mut self, group: String) -> &mut Self {
        self.instruction.group = Some(group);
        self
    }
    #[allow(clippy::clone_on_copy)]
    pub fn build(&self) -> MintV1Cpi<'a> {
        let args = MintV1InstructionArgs {
            mint_args: self
                .instruction
                .mint_args
                .clone()
                .expect("mint_args is not set"),
            group: self.instruction.group.clone(),
        };

        MintV1Cpi {
            __program: self.instruction.__program,

            candy_guard: self
                .instruction
                .candy_guard
                .expect("candy_guard is not set"),

            candy_machine_program: self
                .instruction
                .candy_machine_program
                .expect("candy_machine_program is not set"),

            candy_machine: self
                .instruction
                .candy_machine
                .expect("candy_machine is not set"),

            candy_machine_authority_pda: self
                .instruction
                .candy_machine_authority_pda
                .expect("candy_machine_authority_pda is not set"),

            payer: self.instruction.payer.expect("payer is not set"),

            minter: self.instruction.minter.expect("minter is not set"),

            owner: self.instruction.owner,

            asset: self.instruction.asset.expect("asset is not set"),

            collection: self.instruction.collection.expect("collection is not set"),

            mpl_core_program: self
                .instruction
                .mpl_core_program
                .expect("mpl_core_program is not set"),

            system_program: self
                .instruction
                .system_program
                .expect("system_program is not set"),

            sysvar_instructions: self
                .instruction
                .sysvar_instructions
                .expect("sysvar_instructions is not set"),

            recent_slothashes: self
                .instruction
                .recent_slothashes
                .expect("recent_slothashes is not set"),
            __args: args,
        }
    }
}

struct MintV1CpiBuilderInstruction<'a> {
    __program: &'a solana_program::account_info::AccountInfo<'a>,
    candy_guard: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    candy_machine_program: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    candy_machine: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    candy_machine_authority_pda: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    payer: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    minter: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    owner: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    asset: Option<(&'a solana_program::account_info::AccountInfo<'a>, bool)>,
    collection: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    mpl_core_program: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    system_program: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    sysvar_instructions: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    recent_slothashes: Option<&'a solana_program::account_info::AccountInfo<'a>>,
    mint_args: Option<Vec<u8>>,
    group: Option<String>,
}
